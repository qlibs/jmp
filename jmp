// <!--
//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#ifdef README
// -->
[![Boost Licence](http://img.shields.io/badge/license-boost-blue.svg)](http://www.boost.org/LICENSE_1_0.txt)
[![Version](https://badge.fury.io/gh/qlibs%2Fjmp.svg)](https://github.com/qlibs/jmp/releases)
[![build](https://img.shields.io/badge/build-blue.svg)](https://godbolt.org/z/zxdzjMcGq)
[![Try it online](https://img.shields.io/badge/try%20it-online-blue.svg)](https://godbolt.org/z/TrPd91PG5)

---------------------------------------

## JMP: Static branch library

> https://en.wikipedia.org/wiki/Branch_(computer_science)

### Use cases

> Performance
> - branch is relatively stable through its life cycle `and/or`
> - branch is expensive to compute and/or require memory access `and/or`
> - branch is hard to predict/learn by the hardware

> Examples: logging, tracing, dispatching, ...

### Features

- Single header (https://raw.githubusercontent.com/qlibs/jmp/main/jmp - for integration see [FAQ](#faq))
- Minimal [API](#api)
- Verifies itself upon include (can be disabled with `-DNTEST` - see [FAQ](#faq))

### Requirements

- C++20 ([clang++15+, g++11+](https://en.cppreference.com/w/cpp/compiler_support)) / [x86-64](https://en.wikipedia.org/wiki/X86-64) / [Linux](https://en.wikipedia.org/wiki/Linux)

---

### Overview

> `static_branch<bool>` (https://godbolt.org/z/TrPd91PG5)

```cpp
/**
 * constexpr minimal overhead static branch changed at run-time via code patching
 */
constexpr jmp::static_branch<bool> semi_runtime_branch = false;

/**
 * Note: `fn` can be inline/noinline/constexpr/etc.
 * constexpr void fn();
 * inline void fn();
 * [[gnu::noinline]] void fn()
 * [[gnu::always_inline]] void fn()
 */
void fn() {
  if (semi_runtime_branch) { // [[likely]] / [[unlikely]]
    std::puts("taken");
  } else {
    std::puts("not taken");
  }
}

int main() {
  if (not jmp::init()) { // enables run-time code patching
    return -1; // can't change permissions for code pages
  }

  fn(); // not taken

  semi_runtime_branch = true;
  fn(); // taken
}
```

```cpp
main: // $CXX -O3
  // ... init
  xor eax, eax

// fn (inlined)
  nop
  mov edi, OFFSET FLAT:.LC0
  jmp puts
  ret
.Ltmp1:
  mov edi, OFFSET FLAT:.LC1
  jmp puts
  ret

  call semi_runtime_branch.operator=(true)

// fn (inlined)
  jmp .Ltmp1 // code patching (nop->jmp)
  mov edi, OFFSET FLAT:.LC0
  jmp puts
  ret
.Ltmp1:
  mov edi, OFFSET FLAT:.LC1
  jmp puts
  ret

.LC0: .asciz "not taken"
.LC1: .asciz "taken"
```

```cpp
constexpr jmp::static_branch<bool> semi_runtime_branch = false;

void fn() {
  if (semi_runtime_branch) {
    throw;
  } else {
    std::puts("taken");
  }
}

fn(): // https://godbolt.org/z/jvKGdPMWK
// semi_runtime_branch = false;
  [1]    [2]    [3]    [4]    [5]    [6]    Instructions:
   1      0     0.25                        nop
   1      1     0.33                        lea   rdi, [rip + .L.str]
   1      1     0.50                        jmp   puts
   1      1     1.00           *            .LBB0_1: push  rax
   1      1     0.50                        call  __cxa_rethrow@PLT

// semi_runtime_branch = true;
  [1]    [2]    [3]    [4]    [5]    [6]    Instructions:
   1      1     0.50                        jmp   .LBB0_1
   1      1     0.50                        lea   rdi, [rip + .L.str]
   1      1     0.50                        jmp   puts
   3      2     1.00           *            .LBB0_1: push  rax
   4      3     1.00                        call  __cxa_rethrow@PLT

[1]: #uOps   [2]: Latency  [3]: RThroughput
[4]: MayLoad [5]: MayStore [6]: HasSideEffects (U)
```

```cpp
bool runtime_branch = false;

void fn() {
  if (runtime_branch) {
    throw;
  } else {
    std::puts("taken");
  }
}

fn(): // https://godbolt.org/z/jvKGdPMWK
// runtime_branch = false;
  [1]    [2]    [3]    [4]    [5]    [6]    Instructions:
   2      5     0.50    *                   cmp   byte ptr [rip + runtime_branch], 1
   1      1     0.25                        je    .LBB0_1
   1      1     0.25                        lea   rdi, [rip + .L.str]
   1      1     0.25                        jmp   puts
   1      1     0.50           *            .LBB0_1: push  rax
   1      1     0.25                        call  __cxa_rethrow@PLT

// runtime_branch = true;
  [1]    [2]    [3]    [4]    [5]    [6]    Instructions:
   2      5     0.50    *                   cmp   byte ptr [rip + runtime_branch], 1
   1      1     0.25                        je    .LBB0_1
   1      1     0.25                        lea   rdi, [rip + .L.str]
   1      1     0.25                        jmp   puts
   1      1     0.50           *            .LBB0_1: push  rax
   1      1     0.25                        call  __cxa_rethrow@PLT

[1]: #uOps   [2]: Latency  [3]: RThroughput
[4]: MayLoad [5]: MayStore [6]: HasSideEffects (U)
```

----

> `static_branch<int>` (https://godbolt.org/z/sP8qzMMnj)

```cpp
constexpr jmp::static_branch<int> semi_runtime_branch = 0;

void fn() {
  switch (semi_runtime_branch) {
    default: return;
    case 0: std::puts("0"); return;
    case 1: std::puts("1"); return;
    case 2: std::puts("2"); return;
  }
}

int main() {
  if (not jmp::init()) { // enables run-time code patching
    return -1; // can't change permissions for code pages
  }

  fn(); // 0

  semi_runtime_branch = 1;
  fn(); // 1

  semi_runtime_branch = 2;
  fn(); // 2
}
```

```cpp
fn: // $CXX -O3 -fno-inline
  nop # patching (nop->jmp)
  mov edi, OFFSET FLAT:.LC0
  jmp puts
  ret
.Ltmp1:
  mov edi, OFFSET FLAT:.LC1
  jmp puts
  ret
.Ltmp2:
  mov edi, OFFSET FLAT:.LC2
  jmp puts
  ret

main:
  // ... init

  fn() // 0

  call semi_runtime_branch.operator=(1)
  fn() // 1

  call semi_runtime_branch.operator=(2)
  fn() // 2

.LC0: .asciz "0"
.LC1: .asciz "1"
.LC2: .asciz "2"
```

----

### Examples

> `variant` (https://godbolt.org/z/4Y8f1zWqE) | (https://wg21.link/P2996)

```cpp
template<class... Ts>
class variant {
  static constexpr jmp::static_branch<std::size_t> index_ = 0u;

 public:
   constexpr variant() = default;

   template<class T>
     requires (not std::is_base_of_v<variant, std::remove_cvref_t<T>>)
   constexpr explicit(false) variant(T&& t) {
    constexpr auto index = [] {
      std::array match{std::is_same_v<Ts, std::remove_cvref_t<T>>...};
      return std::ranges::find(match, true) - match.begin();
    }();
    index_ = index;
    std::construct_at(&storage_.[:
      nonstatic_data_members_of(^storage)[index + 1u]
    :], std::forward<T>(t));
   }
   constexpr ~variant()
    requires (std::is_trivially_destructible_v<Ts> and ...) = default;

   template<class Fn>
   constexpr auto visit(Fn&& fn) const -> decltype(auto) {
    return [&]<auto I = 0u>(this auto&& self) {
      if constexpr (I == sizeof...(Ts)) {
        std::unreachable();
      } else {
        switch (index_) {
          default: return self.template operator()<I + 1u>();
          case I:  return std::invoke(std::forward<Fn>(fn), storage_.[:
                            nonstatic_data_members_of(^storage)[I + 1u]
                          :]);
        }
      }
    }();
  }

private:
  union storage;
  struct empty{ };
  static_assert(is_type(define_class(^storage, {
    std::meta::data_member_spec(^empty, {.name = "empty"}),
    std::meta::data_member_spec(^Ts)...
  })));
  storage storage_{.empty={}};
};
```

```cpp
void usage(const variant<bool, int, float>& v) {
  v.visit(overload{
    [](bool)  { std::puts("bool");  },
    [](int)   { std::puts("int");   },
    [](float) { std::puts("float"); },
  });
}

int main() {
  std::ignore = jmp::init();

  variant<bool, int, float> v{};

  v = true;
  usage(v);

  v = 42;
  usage(v);

  v = 42.f;
  usage(v);
}
```

```cpp
usage(variant<bool, int, float> const&):
  nop # patching (nop->jmp)
  mov edi, OFFSET FLAT:.LC0
  jmp puts
  ret
.Ltmp1:
  mov edi, OFFSET FLAT:.LC1
  jmp puts
  ret
.Ltmp2:
  mov edi, OFFSET FLAT:.LC2
  jmp puts
  ret

.LC0: .asciz  "bool"
.LC1: .asciz  "int"
.LC2: .asciz  "float"
```

---

### API

```cpp
inline namespace x86_64 {
struct entry {
  static constexpr size_t offsets = 8u; /// Max number JMP offsets (hardcoded)
  static constexpr size_t size = 5u;    /// sizeof(nop/jmp instruction)
                                        ///
  const void *self{};                   /// Identifier
  void* memory{};                       /// Code memory (to be patched)
  u64 offset[offsets - 1u]{};           /// JMP offsets

  [[nodiscard]] static inline auto begin() noexcept -> const entry*;
  [[nodiscard]] static inline auto end() noexcept -> const entry*;
};

/**
 * Minimal overhead (via code patching) static branch
 */
template<class T>
  requires requires(T t) { reinterpret_cast<T>(t); }
struct static_branch final {
  /**
   * Creates empty class (static_assert(sizeof(static_branch<T>) == 1u))
   * @param direction initial branch direction (direction: should be T{})
   */
  constexpr explicit(false) static_branch(const auto direction) noexcept
    requires requires { T(direction); };

  constexpr static_branch(const static_branch&) noexcept = delete;
  constexpr static_branch(static_branch&&) noexcept = delete;
  constexpr auto& operator=(const static_branch&) noexcept = delete;
  constexpr auto& operator=(static_branch&&) noexcept = delete;

  /**
   * Updates branch direction
   * @param direction new branch direction
   */
  constexpr const auto& operator=(const auto direction) const noexcept
    requires requires { T(direction); };

  /**
   * Updates branch direction
   * @param direction new branch direction for specific entry `pair{direction, entry}`
   */
  constexpr const auto& operator=(const auto direction_entry) const noexcept
    requires requires { T(direction_entry.first); direction_entry.second.offset; };

  [[gnu::always_inline]] [[nodiscard]] inline explicit(false) operator T() const noexcept;
};
} // namespace x86_64
```

> Configuration

```cpp
#define $JMP 4'0'0 // Current library version (SemVer)
```

---

### FAQ

- How does it work?

  > `jmp` is using technique called code patching - which basically means that the code modifies itself.

  `jmp::static_branch` is based on https://docs.kernel.org/staging/static-keys.html and it requires `asm goto` support (gcc, clang).
  `jmp` currently supports x86-64 Linux, but other platforms can be added using the same technique.

  Example

    ```cpp
    constexpr jmp::static_branch<bool> b = false;

    if (b) {
      return 42;
    } else {
      return 0;
    }
    ```

  > Will emit...

    ```cpp
    main:
      .byte 15 31 68 0 0 # nop - https://www.felixcloutier.com/x86/nop
      xor eax, eax # return 0
      ret
    .LBB1:
      mov eax, 42 # return 42
      ret
    ```

  > Will effectively execute...

    ```cpp
    main:
      nop
      xor eax, eax # return 0
      ret
    ```

  > If the branch direction will be changed (at run-time)...

    ```cpp
    b = true;

    if (b) {
      return 42;
    } else {
      return 0;
    }
    ```

  > Will emit...

    ```cpp
    main:
      call b.operator=(true); # nop->jmp or jmp->nop

      jmp .LBB1: (nop->jmp - changed in the memory of the program)
      xor eax, eax # return 0
      ret
    .LBB1:
      mov eax, 42 # return 42
      ret
    ```

- How to integrate with CMake/CPM?

    ```
    CPMAddPackage(
      Name jmp
      GITHUB_REPOSITORY qlibs/jmp
      GIT_TAG v4.0.0
    )
    add_library(mp INTERFACE)
    target_include_directories(mp SYSTEM INTERFACE ${mp_SOURCE_DIR})
    add_library(jmp::jmp ALIAS jmp)
    ```

    ```
    target_link_libraries(${PROJECT_NAME} jmp:jmp)
    ```

- Acknowledgments

  > https://docs.kernel.org/staging/static-keys.html, https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html, https://www.agner.org/optimize/instruction_tables.pdf, https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html, https://www.felixcloutier.com/documents/gcc-asm.html, https://www.felixcloutier.com/x86, https://uops.info/table.html, https://arxiv.org/abs/2308.14185, https://arxiv.org/pdf/2011.13127

<!--
#else
#pragma GCC system_header
#ifndef $JMP
#define $JMP 4'0'0 // SemVer

extern "C" int mprotect(void*, __SIZE_TYPE__, int);
extern "C" void* __start___x86_jmp [[gnu::section("__x86_jmp")]];
extern "C" void* __stop___x86_jmp [[gnu::section("__x86_jmp")]];

namespace jmp::inline v4_0_0 {
using u8  = __UINT8_TYPE__;
using u16 = __UINT16_TYPE__;
using u32 = __UINT32_TYPE__;
using u64 = __UINT64_TYPE__;
using size_t = __SIZE_TYPE__;

#if defined(__x86_64__)
inline namespace x86_64 {
struct entry {
  static constexpr size_t offsets = 8u; /// Max number JMP offsets (hardcoded)
  static constexpr size_t size = 5u;    /// sizeof(nop/jmp instruction)
  using uop_t = struct uop {
    u8 data[size]; [[nodiscard]] constexpr const auto& operator[](size_t I) const { return data[I]; }
  };
  static constexpr uop_t NOP{0x0f, 0x1f, 0x44, 0x00, 0x00}; /// https://www.felixcloutier.com/x86/nop
  struct [[gnu::packed]] JMP{u8 op{0xe9}; u32 offset;};     /// https://www.felixcloutier.com/x86/jmp
  static_assert(sizeof(NOP) == sizeof(JMP));

  const void *self{};         /// Identifier
  void* memory{};             /// Code memory (to be patched)
  u64 offset[offsets - 1u]{}; /// JMP offsets

  [[nodiscard]] static inline auto begin() noexcept -> const entry* { return (const entry*)&__start___x86_jmp; }
  [[nodiscard]] static inline auto end() noexcept -> const entry* { return (const entry*)&__stop___x86_jmp; }
};

/**
 * Minimal overhead (via code patching) static branch
 */
template<class T>
  requires requires(T t) { reinterpret_cast<T>(t); }
struct static_branch final {
  /**
   * Creates empty class (static_assert(sizeof(static_branch<T>) == 1u))
   * @param direction initial branch direction (direction: should be T{})
   */
  constexpr explicit(false) static_branch(const auto direction) noexcept requires requires { T(direction); } {
    void failed(); if (bool(direction)) failed(); /// direction should be set to T{} by default for better performance: { 0: nop, 1..N: jmp }
  }
  constexpr static_branch(const static_branch&) noexcept = delete;
  constexpr static_branch(static_branch&&) noexcept = delete;
  constexpr auto& operator=(const static_branch&) noexcept = delete;
  constexpr auto& operator=(static_branch&&) noexcept = delete;

  /**
   * Updates branch direction
   * @param direction new branch direction
   */
  constexpr const auto& operator=(const auto direction) const noexcept
    requires requires { T(direction); } {
    entry::JMP jmp{}; const entry::uop_t* ops[]{&entry::NOP, (const entry::uop_t*)(&jmp)};
    for (const auto* entry = entry::begin(); entry != entry::end(); ++entry) {
      if (entry->self != this) continue;
      jmp.offset = u32(entry->offset[direction - 1u]);
      *static_cast<entry::uop_t*>(entry->memory) = *ops[bool(direction)];
    }
    return *this;
  }

  /**
   * Updates branch direction
   * @param direction new branch direction for specific entry `pair{direction, entry}`
   */
  constexpr const auto& operator=(const auto direction_entry) const noexcept
    requires requires { T(direction_entry.first); direction_entry.second.offset; } {
    struct uop { entry::uop_t _; };
    const auto& [direction, entry] = direction_entry;
    const entry::JMP jmp{.offset = u32(entry.offset)};
    const entry::uop_t* ops[]{&entry::NOP, (const entry::uop_t*)(&jmp)};
    *static_cast<uop>(entry.memory) = *ops[bool(direction)];
    return *this;
  }

  [[gnu::always_inline]] [[nodiscard]] inline explicit(false) operator T() const noexcept {
    asm volatile goto("0:"
      ".byte %c3, %c4, %c5, %c6, %c7 \n"
      ".pushsection __x86_jmp, \"aw\" \n"
      ".balign %c0 \n"
      ".quad %c1, 0b, %l[_1] - (0b + %c2), %l[_2] - (0b + %c2), %l[_3] - (0b + %c2), \
                      %l[_4] - (0b + %c2), %l[_5] - (0b + %c2), %l[_6] - (0b + %c2), %l[_7] - (0b + %c2) \n"
      ".popsection \n"
      : : "i"(alignof(u64)),
          "i"(this),
          "i"(sizeof(entry::uop_t)),
          "i"(entry::NOP[0]), "i"(entry::NOP[1]), "i"(entry::NOP[2]), "i"(entry::NOP[3]), "i"(entry::NOP[4])
      : : _1, _2, _3, _4, _5, _6, _7);
    _0: return 0; _1: return 1; _2: return 2; _3: return 3;
    _4: return 4; _5: return 5; _6: return 6; _7: return 7;
  }
};
} // namespace x86_64

/**
 * Makes required pages writable for code patching
 * Note: Must be called before changing the branch direction (`branch = ...`)
 *       Should be called only once per application
 * @param page_size page size (default: sysconf(_SC_PAGESIZE))
 * @param permissions protect permissions (default: PROT_READ | PROT_WRITE | PROT_EXEC)
 * @return true if succesful, false on error (errno is set to indicate the error)
 */
[[nodiscard]] static inline auto init(const u64 page_size = 4096u, const u64 permissions = 0b111) noexcept -> bool {
  for (auto* entry = entry::begin(); entry != entry::end(); ++entry) {
    const auto memory = ((u64)entry->memory & ~(page_size - 1u));
    if (mprotect((void*)memory, sizeof(entry::uop_t), permissions)) return false;
  }
  return true;
}
#endif
} // namespace jmp

#ifndef NTEST
static_assert(([] {
  constexpr auto expect = [](bool cond) { if (not cond) { void failed(); failed(); } };

  // jmp::static_branch
  {
    static_assert(1u == sizeof(jmp::static_branch<bool>));
    static_assert(1u == sizeof(jmp::static_branch<jmp::u8>));
    static_assert(1u == sizeof(jmp::static_branch<jmp::u16>));
    static_assert(1u == sizeof(jmp::static_branch<jmp::u32>));
    static_assert(1u == sizeof(jmp::static_branch<jmp::u64>));
    static_assert(1u == sizeof(jmp::static_branch<jmp::size_t>));

    static_assert(not [](auto... ts) { return requires { jmp::static_branch<bool>{ts...}; }; }());
    static_assert(not [](auto... ts) { return requires { jmp::static_branch<bool>{ts...}; }; }(jmp::static_branch<bool>{false}));
    static_assert([](auto direction) { return requires { jmp::static_branch<bool>{direction}; }; }(false));

    static_assert(not [](auto... ts) { return requires { jmp::static_branch<jmp::u32>{ts...}; }; }());
    static_assert(not [](auto... ts) { return requires { jmp::static_branch<jmp::u32>{ts...}; }; }(jmp::static_branch<jmp::u32>{0u}));
    static_assert([](auto direction) { return requires { jmp::static_branch<jmp::u32>{direction}; }; }(0u));
  }
}(), true));
#endif // NTEST
#endif // $JMP
#endif // README
