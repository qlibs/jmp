// <!--
//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#ifdef README
// -->
[![Boost Licence](http://img.shields.io/badge/license-boost-blue.svg)](http://www.boost.org/LICENSE_1_0.txt)
[![Version](https://badge.fury.io/gh/boost-ext%2Fsb.svg)](https://github.com/boost-ext/sb/releases)
[![build](https://img.shields.io/badge/build-blue.svg)](https://godbolt.org/z/WMb9f7MeW)
[![Try it online](https://img.shields.io/badge/try%20it-online-blue.svg)](https://godbolt.org/z/Wdqfrj7ac)

---------------------------------------

## [Minimal] Static branch library

> https://en.wikipedia.org/wiki/Branch_(computer_science)

### Use cases

> When performance matters (smaller overhead than conditional code) and
  in case when branches are not changing too often and/or
  are expensive to compute/access and
  are hard to learn by the hardware predictor due to the random nature.
  For example: logging, tracing, configuration, ...

### Features

- Single header (https://raw.githubusercontent.com/boost-ext/sb/main/sb - for integration see [FAQ](#faq))
- Minimal [API](#api)
- Verifies itself upon include (can be disabled with `-DNTEST` - see [FAQ](#faq))

### Requirements

- C++20 ([clang++12+, g++10+](https://godbolt.org/z/WMb9f7MeW))
- x86-64 (https://en.wikipedia.org/wiki/X86-64)
- Linux (https://en.wikipedia.org/wiki/Linux)

---

### Overview (https://godbolt.org/z/Wdqfrj7ac)

```cpp
void fun() {
  if (sb::static_branch<"my branch">::get()) {
    std::puts("taken");
  } else {
    std::puts("not taken");
  }
}

int main() {
  fun(); // not taken

  sb::static_branch<"my branch">::set(true);
  fun(); // taken

  sb::static_branch<"my branch">::set(false);
  fun(); // not taken
}
```

```cpp
main:
  lea rdi, [rip + .L.str.1]
  nop # code patching (nop->nop)
  lea rdi, [rip + .L.str.2]
 .Ltmp1:
  call puts@PLT # not taken

  call static_branch<"my branch">::set(true) # relatively slow

  lea rdi, [rip + .L.str.1]
  jmp .Ltmp2 # code patching (nop->jmp)
  lea rdi, [rip + .L.str.2]
 .Ltmp2:
  call puts@PLT # taken

  call static_branch<"my branch">::set(false) # relatively slow

  lea rdi, [rip + .L.str.1]
  nop # code patching (nop->nop)
  lea rdi, [rip + .L.str.2]
 .Ltmp3:
  call puts@PLT # not taken

.L.str.1: .asciz  "taken"
.L.str.2: .asciz  "not taken"
```

```cpp
show perf results
```

---

### API

```cpp
/**
 * Named static branch (default: not set)
 * @tparam name branch name, ex. static_branch<"branch">
 */
template<fixed_string Name>
struct static_branch {
  static constexpr u64 id = Name.hash();

  /**
   * Updates branch direction (not thread-safe)
   * @tparam protect_policy policy (default: protect)
   * @param direction new branch direction
   * @return true on success, false otherwise
   */
  template<auto protect_policy = protect>
  static auto set(const bool direction) noexcept -> bool;

  /**
   * Returns current branch direction (thread-safe)
   * @return current branch direction
   */
  [[gnu::always_inline]] static inline auto get() noexcept -> bool;
};
```

```cpp
static constexpr auto protect =
  [](entry* entry, u32 permissions = PROT_READ | PROT_WRITE | PROT_EXEC) {
    return mprotect(entry->code & ~(page_size - 1u), sizeof(OP), permissions));
  };
```

> Configuration

```cpp
#define SB 1'0'0 // Current library version (SemVer)
```

---

### FAQ

- How does it work?

  > `sb` is using technique called code patching, - which basically means that the code modifies itself.

  `sb` idea is based on https://docs.kernel.org/staging/static-keys.html and it requires `asm goto` support (gcc, clang).
  `sb` currently supports x86-64 Linux, but other platforms can be added using the same approach.

  Example:

    ```cpp
    if (static_branch<"how does it work?">::get()) {
      return 42;
    } else {
      return 0;
    }
    ```

  it will emit...

    ```cpp
    main:
      .byte 15 31 68 0 0 # nop - https://www.felixcloutier.com/x86/nop
      xor eax, eax # return 0
      ret
    .LBB1:
      mov eax, 42 # return 42
      ret
    ```

  which will effectively execute (static branch is set to false by default)...

    ```cpp
    main:
      nop
      xor eax, eax # return 0
      ret
    ```

  now, if we change the branch direction (at run-time / before or after the branch)...

    ```cpp
    static_branch<"how does it work?">::set(true);

    if (static_branch<"how does it work?">::get()) {
      return 42;
    } else {
      return 0;
    }
    ```

  it will emit...

    ```cpp
    main:
      # relatively slow, but it will apply code patching for the new branch direction
      call static_branch<"how does it work?">::set(true);

      jmp .LBB1: (nop->jmp - changed in the memory of the program via `set(true)` call)
      xor eax, eax # return 0
      ret
    .LBB1:
      mov eax, 42 # return 42
      ret
    ```

- How to integrate with CMake/CPM?

    ```
    CPMAddPackage(
      Name sb
      GITHUB_REPOSITORY boost-ext/sb
      GIT_TAG v1.0.0
    )
    add_library(mp INTERFACE)
    target_include_directories(mp SYSTEM INTERFACE ${mp_SOURCE_DIR})
    add_library(sb::sb ALIAS sb)
    ```

    ```
    target_link_libraries(${PROJECT_NAME} sb::sb);
    ```

- Acknowledgments

  - https://docs.kernel.org/staging/static-keys.html
  - https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html
  - https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html
  - https://www.agner.org/optimize/instruction_tables.pdf
  - https://www.felixcloutier.com/x86
  - https://uops.info/table.html
  - https://arxiv.org/abs/2308.14185

<!--
#else
#ifndef SB
#define SB 1'0'0 // SemVer
#pragma GCC system_header

#include <cstring>    // std::memcpy
#include <unistd.h>   // PAGESIZE
#include <sys/mman.h> // mprotect

namespace sb::inline v1_0_0 {
using u8  = __UINT8_TYPE__;
using u16 = __UINT16_TYPE__;
using u32 = __UINT32_TYPE__;
using u64 = __UINT64_TYPE__;
struct entry { u64 id{}; u64 code{}; u64 offset{}; u64 state{}; };
template<class T, u32 N>
struct fixed_string {
  consteval explicit(false) fixed_string(const T* str) noexcept {
    for (decltype(N) i{}; i < N; ++i) { data[i] = str[i]; }
  }
  [[nodiscard]] consteval auto size() const noexcept { return N; }
  [[nodiscard]] consteval auto hash() const noexcept -> u32 {
    constexpr u32 FNV_OFFSET = 2166136261u;
    constexpr u32 FNV_32_PRIME = 16777619u;
    u32 hash = FNV_OFFSET;
    for (auto i = 0u; i < N; ++i) {
      hash ^= static_cast<u32>(data[i]);
      hash *= FNV_32_PRIME;
    }
    return hash;
  }
  T data[N]{};
};
template<class T, u32 N> fixed_string(const T (&str)[N]) -> fixed_string<T, N>;
} // sb
extern sb::entry __start___sb [[gnu::section("__sb")]];
extern sb::entry __stop___sb  [[gnu::section("__sb")]];
namespace sb::inline v1_0_0 {
inline namespace x86 {
  static constexpr u8 JMP[]{0xe9}; // https://www.felixcloutier.com/x86/jmp
  static constexpr u8 NOP[]{0x0f, 0x1f, 0x44, 0x00, 0x00}; // https://www.felixcloutier.com/x86/nop
  static constexpr void (*copy[])(const entry*){
    [](const auto* entry) { std::memcpy(reinterpret_cast<void*>(entry->code), &NOP, sizeof(NOP)); },
    [](const auto* entry) {
      struct [[gnu::packed]] { u8 op; u32 offset; } jmp{.op = JMP[0], .offset = static_cast<u32>(entry->offset)};
      static_assert(sizeof(jmp) == sizeof(NOP));
      std::memcpy(reinterpret_cast<void*>(entry->code), &jmp, sizeof(jmp));
    }
  };
  static constexpr auto protect = [](entry* entry, u32 permissions = PROT_READ | PROT_WRITE | PROT_EXEC) {
    if (static thread_local const auto page_size = sysconf(_SC_PAGESIZE); entry->state != permissions and
      mprotect(reinterpret_cast<void*>(entry->code & ~(page_size - 1u)), sizeof(NOP), permissions)) {
      return false;
    }
    entry->state = permissions;
    return true;
  };

/**
 * Named static branch (default: not set)
 * @tparam name branch name, ex. static_branch<"branch">
 */
  template<fixed_string Name>
  struct static_branch {
    static constexpr auto id = Name.hash();

    /**
     * Updates branch direction (not thread-safe)
     * @tparam protect_policy policy (default: protect)
     * @param direction new branch direction
     * @return true on success, false otherwise
     */
    template<auto protect_policy = protect>
    static auto set(const bool direction) noexcept -> bool {
      for (entry* entry = &__start___sb; entry < &__stop___sb; ++entry) {
        if (entry->id != id) continue;
        if (not protect_policy(entry)) return false;
        copy[direction](entry);
      }
      return true;
    }

    /**
     * Returns current branch direction (thread-safe)
     * @return current branch direction
     */
    [[gnu::always_inline]] static inline auto get() noexcept -> bool {
      asm volatile goto("0:"
        ".byte %c3,%c4,%c5,%c6,%c7 \n"
        ".pushsection __sb, \"aw\" \n"
        ".balign %c0 \n"
        ".quad %c1, 0b, %l[true_] - (0b + %c2), 0 \n"
        ".popsection \n"
        : : "i"(sizeof(void*)),
            "i"(id),
            "i"(sizeof(NOP)),
            "i"(NOP[0]), "i"(NOP[1]), "i"(NOP[2]), "i"(NOP[3]), "i"(NOP[4])
        : : true_);
      false_: return false;
      true_:  return true;
    }
  };
} // namespace x86
} // namespace sb

#ifndef NTEST
static_assert(([] {
  // fixed_string
  {
    static_assert(sizeof("") == sb::fixed_string{""}.size());
    static_assert(sizeof("x86") == sb::fixed_string{"x86"}.size());
    static_assert(sizeof("arm64") != sb::fixed_string{"x86"}.size());
    static_assert(sb::fixed_string{"x86"}.hash() == sb::fixed_string{"x86"}.hash());
    static_assert(sb::fixed_string{"arm64"}.hash() != sb::fixed_string{"x86"}.hash());
  }

  // static_branch
  {
    static_assert(sb::static_branch<"x86">::id == sb::static_branch<"x86">::id);
    static_assert(sb::static_branch<"arm64">::id != sb::static_branch<"x86">::id);
  }
}(), true));
#endif // NTEST
#endif // SB
#endif // README
