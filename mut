// <!--
//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#ifdef README
// -->
[![Boost Licence](http://img.shields.io/badge/license-boost-blue.svg)](http://www.boost.org/LICENSE_1_0.txt)
[![Version](https://badge.fury.io/gh/boost-ext%2Fmut.svg)](https://github.com/boost-ext/mut/releases)
[![build](https://img.shields.io/badge/build-blue.svg)](https://godbolt.org/z/33T6jj9rY)
[![Try it online](https://img.shields.io/badge/try%20it-online-blue.svg)](https://godbolt.org/z/fz5zd1cM9)

---------------------------------------

## Mut: Mutable branch library

> https://en.wikipedia.org/wiki/Branch_(computer_science)

### Use cases

> Performance
  - branch is relatively stable through its life cycle `and/or`
  - branch is expensive to compute and/or require memory access `and/or`
  - branch is hard to predict/learn by the hardware

> Examples: logging, tracing, dispatching, ...

### Features

- Single header (https://raw.githubusercontent.com/boost-ext/mut/main/mut - for integration see [FAQ](#faq))
- Minimal [API](#api)
- Verifies itself upon include (can be disabled with `-DNTEST` - see [FAQ](#faq))

### Requirements

- C++20 ([clang++15+, g++11+](https://en.cppreference.com/w/cpp/compiler_support)) / [x86-64](https://en.wikipedia.org/wiki/X86-64) / [Linux](https://en.wikipedia.org/wiki/Linux)

---

### Overview

> `static_bool` (https://godbolt.org/z/fz5zd1cM9)

```cpp
/**
 * constexpr minimal overhead static bool changed at run-time via code patching
 */
constexpr mut::static_bool semi_runtime_branch = false;

/**
 * Note: `fun` can be inline/noinline/constexpr/etc.
 * constexpr void fun();
 * inline void fun();
 * [[gnu::noinline]] void fun()
 * [[gnu::always_inline]] void fun()
 */
void fun() {
  if (semi_runtime_branch) {
    std::puts("taken");
  } else {
    std::puts("not taken");
  }
}

int main() {
  mut::static_bool::init(); // enables run-time code patching

  fun(); // not taken

  semi_runtime_branch = true;
  fun(); // taken

  semi_runtime_branch = false;
  fun(); // not taken
}
```

```cpp
main: // $CXX -O3
  lea rdi, [rip + .L.str.1]
  nop # code patching (nop->nop)
  lea rdi, [rip + .L.str.2]
 .Ltmp1:
  call puts@PLT # not taken

  call semi_runtime_branch.operator=(true)

  lea rdi, [rip + .L.str.1]
  jmp .Ltmp2 # code patching (nop->jmp)
  lea rdi, [rip + .L.str.2]
 .Ltmp2:
  call puts@PLT # taken

  call semi_runtime_branch.operator=(false)

  lea rdi, [rip + .L.str.1]
  nop # code patching (jmp->nop)
  lea rdi, [rip + .L.str.2]
 .Ltmp3:
  call puts@PLT # not taken

  xor  eax, eax # return 0
  ret

.L.str.1: .asciz "taken"
.L.str.2: .asciz "not taken"
```

---

### API

```cpp
/**
 * Minimal overhead (via code patching) static bool
 */
class static_bool final {
 public:
  /**
   * Creates empty class static_bool (sizeof(static_bool) == 1u)
   * @param direction initial branch direction (direction: should be false)
   */
  constexpr explicit(false) static_bool(const auto direction) noexcept;
  constexpr static_bool(const static_bool&) noexcept = delete;
  constexpr static_bool(static_bool&&) noexcept = delete;
  constexpr auto operator=(const static_bool&) noexcept = delete;
  constexpr auto operator=(static_bool&&) noexcept = delete;

  /**
   * Makes required pages writable for code patching
   * Note: Must be called before chaning the branch direction (branch = true|false)
   *       Should be called only once per application
   * @param page_size page size (default: sysconf(_SC_PAGESIZE))
   * @param permissions protect permissions (default: PROT_READ | PROT_WRITE | PROT_EXEC)
   * @return 0 if succesful, -1 on error (errno is set to indicate the error)
   */
  [[nodiscard]] static constexpr auto init(const u64 page_size = sysconf(_SC_PAGESIZE),
                                           const u64 permissions = 0b111) noexcept -> int;

  /**
   * Updates branch direction
   * @param direction new branch direction
   */
  constexpr void operator=(const auto direction) const noexcept;

  /**
   * Returns branch direction
   * @return current branch direction
   */
  [[gnu::always_inline]] [[nodiscard]] inline operator bool() const noexcept;
};
```

> Configuration

```cpp
#define MUT 2'0'0 // Current library version (SemVer)
```

---

### FAQ

- How does it work?

  > `mut` is using technique called code patching - which basically means that the code modifies itself.

  `mut::static_bool` is based on https://docs.kernel.org/staging/static-keys.html and it requires `asm goto` support (gcc, clang).
  `mut` currently supports x86-64 Linux, but other platforms can be added using the same technique.

  Example:

    ```cpp
    constexpr mut::static_bool b = false;

    if (b) {
      return 42;
    } else {
      return 0;
    }
    ```

  it will emit...

    ```cpp
    main:
      .byte 15 31 68 0 0 # nop - https://www.felixcloutier.com/x86/nop
      xor eax, eax # return 0
      ret
    .LBB1:
      mov eax, 42 # return 42
      ret
    ```

  which will effectively execute...

    ```cpp
    main:
      nop
      xor eax, eax # return 0
      ret
    ```

  now, if we change the branch direction at run-time...

    ```cpp
    b = true;

    if (b) {
      return 42;
    } else {
      return 0;
    }
    ```

  it will emit...

    ```cpp
    main:
      call b.operator=(true); # nop->jmp or jmp->nop

      jmp .LBB1: (nop->jmp - changed in the memory of the program)
      xor eax, eax # return 0
      ret
    .LBB1:
      mov eax, 42 # return 42
      ret
    ```

- How to integrate with CMake/CPM?

    ```
    CPMAddPackage(
      Name mut
      GITHUB_REPOSITORY boost-ext/mut
      GIT_TAG v2.0.0
    )
    add_library(mp INTERFACE)
    target_include_directories(mp SYSTEM INTERFACE ${mp_SOURCE_DIR})
    add_library(mut::mut ALIAS mut)
    ```

    ```
    target_link_libraries(${PROJECT_NAME} mut:mut)
    ```

- Acknowledgments

  > https://docs.kernel.org/staging/static-keys.html, https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html, https://www.agner.org/optimize/instruction_tables.pdf, https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html, https://www.felixcloutier.com/documents/gcc-asm.html, https://www.felixcloutier.com/x86, https://uops.info/table.html, https://arxiv.org/abs/2308.14185, https://arxiv.org/pdf/2011.13127

<!--
#else
#ifndef MUT
#define MUT 2'0'0 // SemVer
#pragma GCC system_header

extern "C" int mprotect(void*, __SIZE_TYPE__, int);

namespace mut::inline v2_0_0 {
using u8  = __UINT8_TYPE__;
using u16 = __UINT16_TYPE__;
using u32 = __UINT32_TYPE__;
using u64 = __UINT64_TYPE__;
using size_t = __SIZE_TYPE__;

namespace utility {
template<class T, size_t N>
struct array {
  T data[N]{};
  [[nodiscard]] constexpr const auto& operator[](size_t I) const { return data[I]; }
  static constexpr auto size() { return N; }
};
template<class T, class... Ts> array(T, Ts...) -> array<T, 1u + sizeof...(Ts)>;
} // utility

namespace detail {
struct entry {
  void *self{};   /// identifier
  void* memory{}; /// code memory (to be patched)
  u64 offset{};   /// jmp offset
};
extern "C" entry __start___mut [[gnu::section("__mut")]];
extern "C" entry __stop___mut [[gnu::section("__mut")]];
} // detail

#if defined(__x86_64__)
inline namespace x86 {
/**
 * Minimal overhead (via code patching) static bool
 */
class static_bool final {
  using uop_t = utility::array<u8, 5u>;
  static constexpr uop_t NOP{0x0f, 0x1f, 0x44, 0x00, 0x00}; /// https://www.felixcloutier.com/x86/nop
  struct [[gnu::packed]] JMP{ u8 op{0xe9}; u32 offset; };   /// https://www.felixcloutier.com/x86/jmp
  static_assert(sizeof(NOP) == sizeof(JMP));

 public:
  /**
   * Creates empty class static_bool (sizeof(static_bool) == 1u)
   * @param direction initial branch direction (direction: should be false)
   */
  constexpr explicit(false) static_bool(const auto direction) noexcept {
    void failed(); if (direction) failed(); /// direction should be false by default / performance: { false: nop, true: unconditional jmp }
  }
  constexpr static_bool(const static_bool&) noexcept = delete;
  constexpr static_bool(static_bool&&) noexcept = delete;
  constexpr auto operator=(const static_bool&) noexcept = delete;
  constexpr auto operator=(static_bool&&) noexcept = delete;

  /**
   * Makes required pages writable for code patching
   * Note: Must be called before chaning the branch direction (branch = true/false)
   *       Should be called only once per application
   * @param page_size page size (default: 4096 / sysconf(_SC_PAGESIZE))
   * @param permissions protect permissions (default: 0b111 / PROT_READ | PROT_WRITE | PROT_EXEC)
   * @return 0 if succesful, -1 on error (errno is set to indicate the error)
   */
  [[nodiscard]] static constexpr auto init(const u64 page_size = 4096u, const u64 permissions = 0b111) noexcept -> int {
    for (auto entry = &detail::__start___mut; entry != &detail::__stop___mut; ++entry) {
      const auto memory = reinterpret_cast<void*>((u64)entry->memory & ~(page_size - 1u));
      if (const auto error = mprotect(memory, sizeof(uop_t), permissions)) {
        return error;
      }
    }
    return {};
  }

  /**
   * Updates branch direction
   * @param direction new branch direction
   */
  constexpr void operator=(const auto direction) const noexcept {
    JMP jmp{};
    const uop_t* ops[2]{&NOP, reinterpret_cast<const uop_t*>(&jmp)};
    for (auto entry = &detail::__start___mut; entry != &detail::__stop___mut; ++entry) {
      if (entry->self != this) continue;
      jmp.offset = static_cast<u32>(entry->offset);
      *static_cast<uop_t*>(entry->memory) = *ops[direction];
    }
  }

  /**
   * Returns branch direction
   * @return current branch direction
   */
  [[gnu::always_inline]] [[nodiscard]] inline operator bool() const noexcept {
    asm volatile goto("0:"
      ".byte %c3, %c4, %c5, %c6, %c7 \n"
      ".pushsection __mut, \"aw\" \n"
      ".balign %c0 \n"
      ".quad %c1, 0b, %l[true_] - (0b + %c2) \n"
      ".popsection \n"
      : : "i"(alignof(this)),
          "i"(this),
          "i"(sizeof(uop_t)),
          "i"(NOP[0]), "i"(NOP[1]), "i"(NOP[2]), "i"(NOP[3]), "i"(NOP[4])
      : : true_);
    false_: return false;
    true_:  return true;
  }
};
} // namespace x86
#endif
} // namespace mut

#ifndef NTEST
static_assert(([] {
  constexpr auto expect = [](bool cond) { if (not cond) { void failed(); failed(); } };

  // mut::utility::array
  {
    {
      mut::utility::array<int, 1> a{};
      expect(1u == a.size());
      expect(0 == a[0]);
    }
    {
      mut::utility::array a{1, 2, 3};
      expect(3u == a.size());
      expect(1 == a[0]);
      expect(2 == a[1]);
      expect(3 == a[2]);
    }
  }

  // mut::static_bool
  {
    static_assert(1u == sizeof(mut::static_bool));
    static_assert(not [](auto... ts) { return requires { mut::static_bool{ts...}; }; }());
    static_assert(not [](auto... ts) { return requires { mut::static_bool{ts...}; }; }(mut::static_bool{false}));
    static_assert([](auto direction) { return requires { mut::static_bool{direction}; }; }(false));
  }
}(), true));
#endif // NTEST
#endif // MUT
#endif // README
